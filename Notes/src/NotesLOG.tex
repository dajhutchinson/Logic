\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in, paperwidth=8.3in, paperheight=11.7in]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{changepage} 

\begin{document}

\pagestyle{fancy}
\setlength\parindent{0pt}
\allowdisplaybreaks

\renewcommand{\headrulewidth}{0pt}
\setlist[enumerate,1]{label={(\roman*)}}


% Cover page title
\title{Logic - Notes}
\author{Dom Hutchinson}
\date{\today}
\maketitle

% Header
\fancyhead[L]{Dom Hutchinson}
\fancyhead[C]{Logic - Notes}
\fancyhead[R]{\today}

% Counters
\newcounter{definition}[subsection]
\newcounter{example}[section]
\newcounter{notation}[section]
\newcounter{proposition}[section]
\newcounter{proof}[section]
\newcounter{remark}[section]
\newcounter{theorem}[section]

% commands
\newcommand{\dotprod}[0]{\boldsymbol{\cdot}}
\newcommand{\cosech}[0]{\mathrm{cosech}\ }
\newcommand{\cosec}[0]{\mathrm{cosec}\ }
\newcommand{\sech}[0]{\mathrm{sech}\ }
\newcommand{\prob}[0]{\mathbb{P}}
\newcommand{\nats}[0]{\mathbb{N}}
\newcommand{\cov}[0]{\mathrm{Cov}}
\newcommand{\var}[0]{\mathrm{Var}}
\newcommand{\expect}[0]{\mathbb{E}}
\newcommand{\reals}[0]{\mathbb{R}}
\newcommand{\integers}[0]{\mathbb{Z}}
\newcommand{\indicator}[0]{\mathds{1}}
\newcommand{\nb}[0]{\textit{N.B.} }
\newcommand{\ie}[0]{\textit{i.e.} }
\newcommand{\eg}[0]{\textit{e.g.} }
\newcommand{\X}[0]{\textbf{X}}
\newcommand{\x}[0]{\textbf{x}}
\newcommand{\iid}[0]{\overset{\text{iid}}{\sim}}
\newcommand{\proved}[0]{$\hfill\square$\\}
\newcommand{\lang}[0]{\mathcal{L}}

\newcommand{\definition}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}\\}
\newcommand{\definitionn}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}}
\newcommand{\proof}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}\\}
\newcommand{\prooff}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}}
\newcommand{\example}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}\\}
\newcommand{\examplee}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}}
\newcommand{\notation}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}\\}
\newcommand{\notationn}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}}
\newcommand{\proposition}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}\\}
\newcommand{\propositionn}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}}
\newcommand{\remark}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}\\}
\newcommand{\remarkk}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}}
\newcommand{\theorem}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}\\}
\newcommand{\theoremm}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}}

\tableofcontents

% Start of content
\newpage

\section{Introduction}

\subsection{Alphabets \& Strings}

\definition{Alphabet}
An \textit{Alphabet} is a set of symbols from which \textit{Strings} can be created.\\

\definition{String}
A \textit{String} over a set $\mathcal{A}$ is any sequence $\alpha:=\langle a_1,\dots,a_n\rangle$ where $a_1,\dots,a_n\in\mathcal{A}$.\\
\nb Here we say $\alpha$ has \textit{length} $n$ and $\alpha\in\mathcal{A}^n$.\\

\definition{Power Set}
Let $\mathcal{A}$ be an alphabet. We define
$$\mathcal{A}^*:=\bigcup\limits_{n\in\nats}\mathcal{A}^n=\{\langle a_1,\dots,a_n\rangle:n\in\nats;a_1,\dots,a_n\in\mathcal{A}\}$$
This means $\mathcal{A}^*$ is the set of all possible strings over alphabet $\mathcal{A}$.\\

\remark{Concatenating Strings}
Define \textit{Strings} $\alpha:=\langle a_1,\dots,a_n\rangle\in\mathcal{A}^n$ and $\beta:=\langle b_1,\dots,b_m\rangle\in\mathcal{A}^m$.\\
We define \textit{Concatenation} of $\alpha$ \& $\beta$ as
$\alpha\beta:=\langle a_1,\dots,a_n,b_1,\dots,b_m\rangle$
Note that
$$\alpha\beta\neq\langle\alpha,\beta\rangle=\langle\langle a_1,\dots,a_n\rangle,\langle b_1,\dots,b_m\rangle\rangle$$
\nb Sometimes the following notation is used $\alpha*\beta$.

\example{English Alphabet}
If we define an alphabet $\mathcal{A}:=\{`a`,\dots,`z`\}$ then $\langle`t`,`h`,`i`,`s`\rangle$ is a \textit{String} of $\mathcal{A}$.\\

\remark{Ambiguity when using multiple Alphabets}
Consider the \textit{Alphabets} $\mathcal{A}_1:=\{0,1,\dots,9\}$ \& $\mathcal{A}_2:=\nats$.\\
Then we are unsure which of the following definitions of $123$ is valid
$$\langle123\rangle,\ \langle12,3\rangle,\ \langle1,23\rangle, \langle1,2,3\rangle$$

\remark{$\mathcal{A}:=\{0,1\}$ is sufficient to describe any language - binary}

\remark{Describing Formal Languages}
When describing a \textit{Formal Language} we need to provide two things
\begin{enumerate}
	\item An \textit{Alphabet} which defines what symbols are allowed.
	\item A \textit{Grammar} which defines what combinations of symbols are allowed.
\end{enumerate}

\subsection{Countable Sets}

\definition{Countable Set}
A set $X$ is said to be \textit{Countable} if
\[\begin{array}{l}
\exists\text{ a surjection  }f:\nats\to X\\
\exists\text{ an injection }f:X\to\nats
\end{array}\]

\definition{Countably Infinite Set}
A set $X$ is said to be \textit{Countably Infinite} if $\exists$ a bijection $f:X\to\nats$.\\

\theorem{Power set is Countable}
If set $\mathcal{A}$ is \textit{countable} then $\mathcal{A}^*$ is \textit{countable}.\\

\proof{Theorem 1.1}
Let $f:\mathcal{A}\to\nats$ (This function exists trivally since we define $\mathcal{A}$ to be countable).\\
Define the following function $g(\cdot):\mathcal{A}^*\to\nats$
$$g(\langle a_1,\dots,a_n\rangle):=p_1^{f(a_1)+1}\cdot\dots\cdot p_n^{f(a_n)+1}$$
where $p_i$ is the $i^\text{th}$ prime.\\
Since each natural number can be described by a unique composition of primes and since $f(\dot)$ is injective, then $g(\cdot)$ is injective.\\
Thus there exists an injection from $\mathcal{A}^*$ to $\nats$, making $\mathcal{A}^*$ countable.\\

\theorem{If $\mathcal{A}$ is countable, then so are $\mathcal{A}^*,(\mathcal{A}^*)^*,\dots$}

\section{First-Order Languages}

\definition{First-Order Language, $\lang$}
The \textit{Alphabet} of a \textit{First-Order Language}, comprises of the following, pairwise disjoint, categories (and nothing else)
\begin{enumerate}
	\item Negation, $\neg$, and implication, $\implies$.
	\item For all, $\forall$.
	\item Infinitely many variables, $\{v_0,v_1,\dots\}$.
	\item Parentheses, `$($' `$)$', and comman `$,$'.
	\item Equality, $\equiv$, which is the only logical predicate symbol with 2-arity.
	\item A set of constant symbols, $\{c_1,c_2,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity function symbols $\{f_1^n,f_2^n,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity non-logical predicate symbols $\{P_1^n,P_2^n,\dots\}$. (Possibly empty)
\end{enumerate}
\nb We denote the set of variables by $Var:=\{v_0,v_1,\dots\}$; denote a language as $\lang$ and the alphabet of $\lang$ as $\mathcal{A_L}$.\\
\nb In this course \textit{Alphabets} are restricted to being \textit{Countable}.\\

\definition{Negation, $\neg$}
Negation returns in the inverse of a predicate (DO I MEAN PREDICATE)
\begin{center}
\begin{tabular}{c|c}
$P$&$\neg P$\\\hline
T&F\\
F&T
\end{tabular}
\end{center}

\definition{Implication, $\implies$}
Implication returns whether one predicate being true necessarily implies a second predicate being true
\begin{center}
\begin{tabular}{cc|c}
$P$&$Q$&$P\implies Q$\\\hline
T&T&T\\
T&F&F\\
F&T&T\\
F&F&T
\end{tabular}
\end{center}

\remark{First-Order Languages don't have $\wedge,\ \vee,\ \exists$}
Alphabets for \textit{First-Order Languages} do not contain propositional connectives for AND, $\wedge$, OR, $\vee$, or EXISTS,$\exists$ since they can be expressed as a combination of negation \& implication.
\[\begin{array}{rcl}
P\vee Q&\Longleftrightarrow& \neg P\implies Q\\P\wedge Q&\Longleftrightarrow&\neg(P\implies\neg Q)\\
\exists\ x\text{ st }P(x)\text{ is true}&\Longleftrightarrow&\neg(\forall\ x,\ \neg P(x))
\end{array}\]
\begin{center}
\begin{tabular}{cc}
\begin{tabular}{cc|c|c}
$P$&$Q$&$\neg P$&$\neg P\implies Q$\\\hline
T&T&F&T\\
T&F&F&T\\
F&T&F&T\\
F&F&F&F
\end{tabular}&
\begin{tabular}{cc|c|c|c}
$P$&$Q$&$\neg Q$&$P\implies\neg Q$&$\neg(P\implies\neg Q)$\\\hline
T&T&F&F&T\\
T&F&T&T&F\\
F&T&F&T&F\\
F&F&T&T&F
\end{tabular}
\end{tabular}\\
\end{center}

\example{Recursive Defintion}
Consider the following, normal, deifition
$$x\text{ is a multiple of }5\Longleftrightarrow\exists\ y\in\mathbb{Z}\ \text{st}\ y.5=x$$
We can instead use the recursive definition
\begin{enumerate}
	\item $0$ is a multiple of $5$.
	\item If $n$ is a multiple of 5 then $n+5$ is a multiple of 5.
\end{enumerate}

\definition{$\lang$-Term \& Complexity}
Let $\lang$ be a \textit{First-Order Language}.\\
We define \textit{$\lang$-Terms} \& \textit{Complexity}, $cp(\cdot)$, together using the following \textit{recursive definition}
\begin{enumerate}
	\item If $s$ is a variable or a constant symbol, then $s$ is an \textit{$\lang$-Term} with $cp(s)=0$.\\
	\nb Terms with $cp(\cdot)=0$ are called \textit{Atomic Terms}.
	\item If $f$ is a fucntion symbol with $k$-arity \& if $a_1,\dots,a_k$ are \textit{$\lang$-Terms} then $f(a_1,\dots,f_k)$ is an \textit{$\lang$-Term} with complexity
	$$cp(f(a_1,\dots,a_k)):=\max\{cp(a_1),\dots,cp(a_k)\}+1$$
	\nb Terms with $cp(\cdot)\geq1$ are called \textit{Compound Terms}.
	\item Nothing else is an \textit{$\lang$-Term}
\end{enumerate}
\nb We denote the set of $\lang-\text{Terms}$ by $T_\mathcal{M_L}$

\example{Complexity}
Let $\{c,d,f,g,h,p\}\subseteq\lang$ with $c,d$ being constants, $g,p$ being uniary functions \& $f,h$ being binary functions.\\
Show that the following is an $\lang$\textit{-Term} \& find its \textit{Complexity}
$$h(g(f(x,c)),p(d))$$
\begin{enumerate}
	\item $x$ is an $\lang$\textit{-Term} with $cp(x)=0$ by $(i)$.
	\item $c\ \&\ d$ are $\lang$\textit{-Terms} with $cp(c)=0=cp(d)$ by $(i)$.
	\item $f(x,c)$ is an $\lang$\textit{-Term} with $cp(f)=\max{0,0}+1=1$ by $(ii)$.
	\item $p(d)$ is an $\lang$\textit{-Term} with $cp(f)=\max{0}+1=1$ by $(ii)$.
	\item $g(f(x,c),p(d))$ is an $\lang$\textit{-Term} with $cp(g)=\max{1,1}+1=2$ by $(ii)$.
	\item $h(g(f(x,c),p(d)))$ is an $\lang$\textit{-Term} with $cp(h)=\max{2}+1=3$ by $(ii)$.
\end{enumerate}
Thus $h(g(f(x,c),p(d)))$ is an $\lang$\textit{-Term} with \textit{Complexity} 3.\\

\notation{More readble Functions}
WE often write $x\circ y$ instead of $\circ(x,y)$ as it is more readable (even though the later is technically the only correct notation). Similarly, $x+y$ instead of $+(x,y)$.\\

\definition{Atomic Formulae}
Let $\lang$ be a \textit{First-Order Language}.\\
The atomic $\lang$\textit{-Formulae} are those strings over $\mathcal{A_L}$ of the form
$$R(t_1,\dots,t_n)\text{ for }n\in\nats$$
where $R$ is a predicate symbol of $\lang$ with $n$-arity and $t_1,\dots,t_n$ are $\lang$\textit{-terms}.\\
\nb $\equiv(t_1,t_2)$ is an \textit{Atomic $\lang$-Formula} for each $\lang$ terms $t_1,t_2$

\end{document}
