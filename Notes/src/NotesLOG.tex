\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in, paperwidth=8.3in, paperheight=11.7in]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{eufrak}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{changepage} 

\begin{document}

\pagestyle{fancy}
\setlength\parindent{0pt}
\allowdisplaybreaks

\renewcommand{\headrulewidth}{0pt}
\setlist[enumerate,1]{label={\roman*)}}


% Cover page title
\title{Logic - Notes}
\author{Dom Hutchinson}
\date{\today}
\maketitle

% Header
\fancyhead[L]{Dom Hutchinson}
\fancyhead[C]{Logic - Notes}
\fancyhead[R]{\today}

% Counters
\newcounter{definition}[subsection]
\newcounter{example}[section]
\newcounter{notation}[section]
\newcounter{proposition}[section]
\newcounter{proof}[section]
\newcounter{remark}[section]
\newcounter{theorem}[section]

% commands
\newcommand{\dotprod}[0]{\boldsymbol{\cdot}}
\newcommand{\cosech}[0]{\mathrm{cosech}\ }
\newcommand{\cosec}[0]{\mathrm{cosec}\ }
\newcommand{\sech}[0]{\mathrm{sech}\ }
\newcommand{\prob}[0]{\mathbb{P}}
\newcommand{\nats}[0]{\mathbb{N}}
\newcommand{\cov}[0]{\mathrm{Cov}}
\newcommand{\var}[0]{\mathrm{Var}}
\newcommand{\expect}[0]{\mathbb{E}}
\newcommand{\reals}[0]{\mathbb{R}}
\newcommand{\integers}[0]{\mathbb{Z}}
\newcommand{\indicator}[0]{\mathds{1}}
\newcommand{\nb}[0]{\textit{N.B.} }
\newcommand{\ie}[0]{\textit{i.e.} }
\newcommand{\eg}[0]{\textit{e.g.} }
\newcommand{\X}[0]{\textbf{X}}
\newcommand{\x}[0]{\textbf{x}}
\newcommand{\iid}[0]{\overset{\text{iid}}{\sim}}
\newcommand{\proved}[0]{$\hfill\square$\\}
\newcommand{\LL}[0]{\mathcal{L}}
\newcommand{\M}[0]{\mathfrak{M}}

\newcommand{\definition}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}\\}
\newcommand{\definitionn}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}}
\newcommand{\proof}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}\\}
\newcommand{\prooff}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}}
\newcommand{\example}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}\\}
\newcommand{\examplee}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}}
\newcommand{\notation}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}\\}
\newcommand{\notationn}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}}
\newcommand{\proposition}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}\\}
\newcommand{\propositionn}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}}
\newcommand{\remark}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}\\}
\newcommand{\remarkk}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}}
\newcommand{\theorem}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}\\}
\newcommand{\theoremm}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}}

\tableofcontents

% Start of content
\newpage

\section{Introduction}

\subsection{Alphabets \& Strings}

\definition{Alphabet}
An \textit{Alphabet} is a set of symbols from which \textit{Strings} can be created.\\

\definition{String}
A \textit{String} over a set $\mathcal{A}$ is any sequence $\alpha:=\langle a_1,\dots,a_n\rangle$ where $a_1,\dots,a_n\in\mathcal{A}$.\\
\nb Here we say $\alpha$ has \textit{length} $n$ and $\alpha\in\mathcal{A}^n$.\\

\definition{Power Set}
Let $\mathcal{A}$ be an alphabet. We define
$$\mathcal{A}^*:=\bigcup\limits_{n\in\nats}\mathcal{A}^n=\{\langle a_1,\dots,a_n\rangle:n\in\nats;a_1,\dots,a_n\in\mathcal{A}\}$$
This means $\mathcal{A}^*$ is the set of all possible strings over alphabet $\mathcal{A}$.\\

\remark{Concatenating Strings}
Define \textit{Strings} $\alpha:=\langle a_1,\dots,a_n\rangle\in\mathcal{A}^n$ and $\beta:=\langle b_1,\dots,b_m\rangle\in\mathcal{A}^m$.\\
We define \textit{Concatenation} of $\alpha$ \& $\beta$ as
$\alpha\beta:=\langle a_1,\dots,a_n,b_1,\dots,b_m\rangle$
Note that
$$\alpha\beta\neq\langle\alpha,\beta\rangle=\langle\langle a_1,\dots,a_n\rangle,\langle b_1,\dots,b_m\rangle\rangle$$
\nb Sometimes the following notation is used $\alpha*\beta$.

\example{English Alphabet}
If we define an alphabet $\mathcal{A}:=\{`a`,\dots,`z`\}$ then $\langle`t`,`h`,`i`,`s`\rangle$ is a \textit{String} of $\mathcal{A}$.\\

\remark{Ambiguity when using multiple Alphabets}
Consider the \textit{Alphabets} $\mathcal{A}_1:=\{0,1,\dots,9\}$ \& $\mathcal{A}_2:=\nats$.\\
Then we are unsure which of the following definitions of $123$ is valid
$$\langle123\rangle,\ \langle12,3\rangle,\ \langle1,23\rangle, \langle1,2,3\rangle$$

\remark{$\mathcal{A}:=\{0,1\}$ is sufficient to describe any language - binary}

\remark{Describing Formal Languages}
When describing a \textit{Formal Language} we need to provide two things
\begin{enumerate}
	\item An \textit{Alphabet} which defines what symbols are allowed.
	\item A \textit{Grammar} which defines what combinations of symbols are allowed.
\end{enumerate}

\subsection{Countable Sets}

\definition{Countable Set}
A set $X$ is said to be \textit{Countable} if
\[\begin{array}{l}
\exists\text{ a surjection  }f:\nats\to X\\
\exists\text{ an injection }f:X\to\nats
\end{array}\]

\definition{Countably Infinite Set}
A set $X$ is said to be \textit{Countably Infinite} if $\exists$ a bijection $f:X\to\nats$.\\

\theorem{Power set is Countable}
If set $\mathcal{A}$ is \textit{countable} then $\mathcal{A}^*$ is \textit{countable}.\\

\proof{Theorem 1.1}
Let $f:\mathcal{A}\longrightarrow\nats$ (This function exists trivally since we define $\mathcal{A}$ to be countable).\\
Define the following function $g(\cdot):\mathcal{A}^*\longrightarrow\nats$
$$g(\langle a_1,\dots,a_n\rangle):=p_1^{f(a_1)+1}\cdot\dots\cdot p_n^{f(a_n)+1}$$
where $p_i$ is the $i^\text{th}$ prime.\\
Since each natural number can be described by a unique composition of primes and since $f(\dot)$ is injective, then $g(\cdot)$ is injective.\\
Thus there exists an injection from $\mathcal{A}^*$ to $\nats$, making $\mathcal{A}^*$ countable.\\

\theorem{If $\mathcal{A}$ is countable, then so are $\mathcal{A}^*,(\mathcal{A}^*)^*,\dots$}

\section{First-Order Languages}

\definition{First-Order Language, $\LL$}
The \textit{Alphabet} of a \textit{First-Order Language}, comprises of the following, pairwise disjoint, categories (and nothing else)
\begin{enumerate}
	\item Negation, $\neg$, and implication, $\longrightarrow$.
	\item For all, $\forall$.
	\item Infinitely many variables, $\{v_0,v_1,\dots\}$.
	\item Parentheses, `$($' `$)$', and comman `$,$'.
	\item Equality, $\equiv$, which is the only logical predicate symbol with 2-arity.
	\item A set of constant symbols, $\{c_1,c_2,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity function symbols $\{f_1^n,f_2^n,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity non-logical predicate symbols $\{P_1^n,P_2^n,\dots\}$. (Possibly empty)
\end{enumerate}
\nb We denote the set of variables by $Var:=\{v_0,v_1,\dots\}$; denote a language as $\LL$ and the alphabet of $\LL$ as $\mathcal{A_L}$.\\
\nb In this course \textit{Alphabets} are restricted to being \textit{Countable}.\\

\definition{Negation, $\neg$}
Negation returns in the inverse of a predicate (DO I MEAN PREDICATE)
\begin{center}
\begin{tabular}{c|c}
$P$&$\neg P$\\\hline
T&F\\
F&T
\end{tabular}
\end{center}

\definition{Implication, $\longrightarrow$}
Implication returns whether one predicate being true necessarily implies a second predicate being true
\begin{center}
\begin{tabular}{cc|c}
$P$&$Q$&$P\to Q$\\\hline
T&T&T\\
T&F&F\\
F&T&T\\
F&F&T
\end{tabular}
\end{center}

\remark{First-Order Languages don't have $\wedge,\ \vee,\ \exists$}
Alphabets for \textit{First-Order Languages} do not contain propositional connectives for AND, $\wedge$, OR, $\vee$, or EXISTS,$\exists$ since they can be expressed as a combination of negation \& implication.
\[\begin{array}{rcl}
P\vee Q&\Longleftrightarrow& \neg P\to Q\\P\wedge Q&\Longleftrightarrow&\neg(P\to\neg Q)\\
\exists\ x\text{ st }P(x)\text{ is true}&\Longleftrightarrow&\neg(\forall\ x,\ \neg P(x))
\end{array}\]
\begin{center}
\begin{tabular}{cc}
\begin{tabular}{cc|c|c}
$P$&$Q$&$\neg P$&$\neg P\to Q$\\\hline
T&T&F&T\\
T&F&F&T\\
F&T&F&T\\
F&F&F&F
\end{tabular}&
\begin{tabular}{cc|c|c|c}
$P$&$Q$&$\neg Q$&$P\to\neg Q$&$\neg(P\to\neg Q)$\\\hline
T&T&F&F&T\\
T&F&T&T&F\\
F&T&F&T&F\\
F&F&T&T&F
\end{tabular}
\end{tabular}\\
\end{center}

\example{Recursive Defintion}
Consider the following, normal, deifition
$$x\text{ is a multiple of }5\Longleftrightarrow\exists\ y\in\mathbb{Z}\ \text{st}\ y.5=x$$
We can instead use the recursive definition
\begin{enumerate}
	\item $0$ is a multiple of $5$.
	\item If $n$ is a multiple of 5 then $n+5$ is a multiple of 5.
\end{enumerate}

\definition{$\LL$-Term \& Complexity}
Let $\LL$ be a \textit{First-Order Language}.\\
We define \textit{$\LL$-Terms} \& \textit{Complexity}, $cp(\cdot)$, together using the following \textit{recursive definition}
\begin{enumerate}
	\item If $s$ is a variable or a constant symbol, then $s$ is an \textit{$\LL$-Term} with $cp(s)=0$.\\
	\nb Terms with $cp(\cdot)=0$ are called \textit{Atomic Terms}.
	\item If $f$ is a fucntion symbol with $k$-arity \& if $a_1,\dots,a_k$ are \textit{$\LL$-Terms} then $f(a_1,\dots,f_k)$ is an \textit{$\LL$-Term} with complexity
	$$cp(f(a_1,\dots,a_k)):=\max\{cp(a_1),\dots,cp(a_k)\}+1$$
	\nb Terms with $cp(\cdot)\geq1$ are called \textit{Compound Terms}.
	\item Nothing else is an \textit{$\LL$-Term}
\end{enumerate}
\nb We denote the set of $\LL-\text{Terms}$ by $T_\mathcal{M_L}$.\\

\example{$\LL$-Term \& Complexity}
Let $\{c,d,f,g,h,p\}\subseteq\L$ with $c,d$ being constants, $g,p$ being uniary functions \& $f,h$ being binary functions.\\
Show that the following is an $\LL$\textit{-Term} \& find its \textit{Complexity}
$$h(g(f(x,c)),p(d))$$
\begin{enumerate}
	\item $x$ is an $\LL$\textit{-Term} with $cp(x)=0$ by $(i)$.
	\item $c\ \&\ d$ are $\LL$\textit{-Terms} with $cp(c)=0=cp(d)$ by $(i)$.
	\item $f(x,c)$ is an $\LL$\textit{-Term} with $cp(f)=\max{0,0}+1=1$ by $(ii)$.
	\item $p(d)$ is an $\LL$\textit{-Term} with $cp(f)=\max{0}+1=1$ by $(ii)$.
	\item $g(f(x,c),p(d))$ is an $\LL$\textit{-Term} with $cp(g)=\max{1,1}+1=2$ by $(ii)$.
	\item $h(g(f(x,c),p(d)))$ is an $\LL$\textit{-Term} with $cp(h)=\max{2}+1=3$ by $(ii)$.
\end{enumerate}
Thus $h(g(f(x,c),p(d)))$ is an $\LL$\textit{-Term} with \textit{Complexity} 3.\\

\notation{More readble Functions}
WE often write $x\circ y$ instead of $\circ(x,y)$ as it is more readable (even though the later is technically the only correct notation). Similarly, $x+y$ instead of $+(x,y)$.\\

\definition{Atomic Formulae}
Let $\LL$ be a \textit{First-Order Language}.\\
The atomic $\LL$\textit{-Formulae} are those strings over $\mathcal{A_L}$ of the form
$$R(t_1,\dots,t_n)\text{ for }n\in\nats$$
where $R$ is a predicate symbol of $\LL$ with $n$-arity and $t_1,\dots,t_n$ are $\LL$\textit{-terms}.\\
\nb $\equiv(t_1,t_2)$ is an \textit{Atomic $\LL$-Formula} for each $\LL$ terms $t_1,t_2$.\\

\definition{$\LL$-Formulae \& Complexity}
We define \textit{$\LL$-Formulae} \& \textit{Complexity}, $cp(\cdot)$, together using the following recursive definition
\begin{enumerate}
	\item If $\phi\in\mathcal{A}^*_\LL$ is an \textit{Atomic $\LL$-Formula} then $\phi$ is an \textit{$\LL$-Formula} with $cp(\phi)=0$.
	\item If $\phi$ is an \textit{$\LL$-Formula} with $cp(\phi)=n$ then $\neg\phi$ is an \textit{$\LL$-Formula} with $cp(\neg\phi)=n+1$.
	\item If $\phi\ \&\ \psi$ are \textit{$\LL$-Formulae} then $\phi\to\psi$ is an \textit{$\LL$-Formula} with ${cp(\phi\to\psi)=\max\{cp(\phi),cp(\psi)\}+1}$.
	\item if $\phi$ is an \textit{$\LL$-Formula} then $\forall x\phi$ is an \textit{$\LL$-Formula} with $cp(\forall x\phi)=cp(\phi)+1$, where $x$ is a variable.
\end{enumerate}
\nb \textit{Complexity} is just a measure of the syntactic complexity, not semantic. Notice how ${cp(\neg\neg\phi)=cp(\phi)+2}$.\\

\remark{Formulae are uniquely readable \& parsable}

\example{\textit{$\LL$-Formulae} Complexity}
Let $\{R,f\}\subset\mathcal{L}$ be binary operations.\\
Show that the following is an \textit{$\LL$-Formula}
$$\forall\ v_0\ (\neg R(f(v_0,v_2),v_2)\longrightarrow\underbrace{\equiv(v_0,v_2)}_{v_0\equiv v_2}$$
\begin{enumerate}
	\item $v_0,v_2$ are $\LL$-Terms.
	\item $f(v_0,v_2)$ is an $\LL$-Term.
	\item $R(f(v_0,v_2),v_2)$ is an $\LL$-Formula with $cp(\cdot)=0$.
	\item $\neg R(f(v_0,v_2),v_2)$ is an $\LL$-Formula with $cp(\cdot)=0+1=1$.
	\item $\equiv(v_0,v_2)$ is an $\LL$-Formula with $cp(\cdot)=0$.
	\item $\neq R(f(v_0,v_2),v_2)\longrightarrow\equiv(v_0,v_2)$ is an $\LL$-Formula with $cp(\cdot)=\max\{0,1\}+1=2$.
	\item $\forall\ v_0\ (\neg R(f(v_0,v_2),v_2)\longrightarrow\equiv(v_0,v_2))$ is an $\LL$-Formula with $cp(\dot)=2+1=3$.
\end{enumerate}

\notation{Convention for common operators}
To make formulae more readble we general make the following allowances in notation
\[\begin{array}{rcl}
t_1\equiv t_2&\text{for}&\equiv(t_1,t_2)\\
t_1\not\equiv t_2&\text{for}&\neg\equiv(t_1,t_2)\\
t_1< t_2&\text{for}&<(t_1,t_2)\\
t_1\not\equiv t_2&\text{for}&\neg\equiv(t_1,t_2)
\end{array}\]
Further, when a formula is encapsulated by parantheses then we will often surpress the outermost parentheses (only), as they do not affect anything.
$$\phi\longrightarrow(\psi\longrightarrow\theta)\text{ for }(\phi\longrightarrow(\psi\longrightarrow\theta))$$

\definitionn{More complex operators}
\begin{itemize}
	\item[-] AND, $(\phi\wedge\psi):=\neg(\phi\longrightarrow\neg\psi)$.
	\item[-] OR, $(\phi\vee\psi):=(\neg\phi\longrightarrow\psi)$.
	\item[-] IFF, $(\phi\longleftrightarrow\psi):=(\phi\longrightarrow\psi)\wedge(\psi\longrightarrow\phi)$.
	\item[-] EXISTS, $(\exists\ x\phi):=\neg\forall\ x\ \neg\phi$.
\end{itemize}

\notationn{Sets of $\LL$ Features}
\begin{itemize}
	\item[-] $T_\mathcal{M_L}:=$ Set of $\LL$-Terms.
	\item[-] $F_\mathcal{M_L}:=$ Set of $\LL$-Formulae.
	\item[-] $\text{Var}:=$ Set of Variables.
\end{itemize}

\propositionn{$T_\mathcal{M_L}\ \&\ F_\mathcal{M_L}$ are always countable in this course since we assume $\LL$ to be finite.}

\subsection{Induction of Terms \& Formulae}

\theorem{Inheritance of a Proeprty - $\LL$-Terms}
Let $P$ be a property of $\LL$-Terms.\\
Suppose the following to be true
\begin{enumerate}
	\item All \textit{Atomic $\LL$-Terms} have property $P$.
	\item $\forall\ k\in\nats,\ \forall$ function symbols $f$ with $k$-arity:
	If $\LL$-Terms $t_1,\dots,t_k$ have property $P$ then $f(t_1,\dots,t_k)$ has $P$.
\end{enumerate}
Then every $\LL$-Term has property $P$.\\

\proof{Theorem 2.1}
\textit{This is a proof by contradiction}.
Suppose that $i)\ \&\ ii)$ are true but there exists some $\LL$-Term which does not have $P$.\\
Let $t$ be an $\LL$-Term with minimum complexity st $t$ does not have $P$.\\
Then $cp(t)\neq0$ otherwise $i)$ would be untrue.\\
Thus $t\equiv f(t_1,\dots,t_k)$ by the minimlaity of $cp(t)$.\\
We know that $t_1,\dots,t_k$ have $P$.\\
Thus $f(t_1,\dots,t_k)$ has $P$. This is a contradiction.\\

\theorem{Inheritance of a Proeprty - $\LL$-Formulae}
Let $P$ be a property of $\LL$-Formula.\\
Suppose the following to be true
\begin{enumerate}
	\item All \textit{Atomic $\LL$-Formulae} have property $P$.
	\item If $\phi,\psi\in F_\mathcal{M_L}$ have $P$ then $\neg\phi,(\phi\to\psi)\ \&\ \forall\ x\phi$ have $P$ to.
\end{enumerate}
Then every $\LL$-Formulae has property $P$.\\

\theorem{Number of Parenthese}
Ever \textit{$\LL$-Formula} has as many left parentheses as right parentheses.\\
Ever \textit{$\LL$-Term} has as many left parentheses as right parentheses.\\

\proof{Theorem 2.3}
\textit{This is a proof by induction}.\\
Let $P$ be the property \textit{``Has as many left parenthese as right''}.\\
\underline{Base Case} - When $\phi$ is an \textit{Atomic $\LL$ Formula} it trivially has equal number of parenthese.\\
\underline{Inductive Case}\\
Let $\phi\ \&\ \psi$ be arbitrary $\LL$-Formulae.\\
Assume that $P(\phi)$ \& $P(\psi)$ hold.\\
We need to show that $P(\neg\phi),\ P(\phi\to\psi)\ \&\ P(\forall\ x\phi)$ all hold.\\
We do not need to show $P(\neg\psi),\ P(\psi\to\phi)\ \&\ P(\forall\ x\psi)$ hold as $\phi\ \&\ \psi$ are arbitrary.\\
We have that $\neg\phi$ and $\forall\ x\phi$ don't add any brackets, so $P$ holds.\\
We have that $(\phi\to\psi)$ add one left \& one right parentheses (although they are often surpressed), thus $P$ holds.\\
Thus by the process of mathematical induction $P$ holds forall $\LL$-Formulae.\\
\nb The proof for $\LL$-Terms is very similar.

\subsection{Free Variables}

\definition{Variable Function, $var(\cdot)$}
Define $var:\mathcal{A_L}^*\to2^\text{Var}$ st $var(s)$ is the set of all variables in string $s$.\\

\examplee{$\var(\cdot)$}
\[\begin{array}{rcl}
var(f(x,f(y,c))&=&\{x,y\}\\
var(f(c,f(c,c))&=&\emptyset\\
var(\equiv,\equiv,\equiv)&=&\emptyset\text{ nonsense strins are acceptable}
\end{array}\]

\definition{Free Variables}
\textit{Free Variables} are variables whose value are ambiguous in an \textit{$\LL$-Formula}.\\

\definition{Free Variable Function, $FV(\cdot)$}
We recursively define $FV(\phi)$ for \textit{$\LL$-Formulae} as $\phi$ as follows
\begin{enumerate}
	\item $FV(\phi)=var(\phi)$ if $\phi$ is an \textit{Atomic $\LL$-Formula}.
	\item $FV(\neg\phi)=FV(\phi)$.
	\item $FV((\phi\to\psi))=FV(\phi)\cup FV(\psi)$.
	\item $FV(\forall\ x\phi)=FV(\phi)\backslash\{x\}$.
\end{enumerate}

\examplee{Free Variable Function}
\[\begin{array}{rcl}
FV(\forall x(P(y)\to Q(x)))&=&FV(P(y)\to Q(x))\backslash\{x\}\\
&=&[FV(P(y))\cup FV(Q(x))]\backslash\{x\}\\
&=&[\{y\}\cup\{x\}]\backslash\{x\}\\
&=&\{y\}
\end{array}\]

\propositionn{Free Variable Function for more complex operators}
\[\begin{array}{rcl}
FV(\phi\wedge\psi)&=&FV(\neg(\phi\to\neg\psi))\text{ by definition of }\wedge\\
&=&FV(\phi)\cup FV(\psi)\\
FV(\phi\vee\psi)&=&FV(\neg\phi\to\psi)\text{ by definition of }\vee\\
&=&FV(\phi)\cup FV(\psi)\\
FV(\exists x\phi)&=&FV(\neg\forall x\neg\phi)\text{ by definition of }\exists\\
&=&FV(\phi)\backslash\{x\}
\end{array}\]

\definition{Closed $\LL$-Term}
Let $t$ be an $\LL$-Term.\\
If $var(t)=\emptyset$ then $t$ is called a \textit{Closed $\LL$-Term}.\\

\definition{$\LL$-Sentence}
Let $\phi$ be an $\LL$-Formula.\\
If $FV(\phi)=\emptyset$ then $\phi$ is called an \textit{$\LL$-Sentence}.\\

\examplee{$\LL$-Sentence}
\[\begin{array}{rcl}
FV(\forall x(P(x)\to\exists y\ R(y,x))&=&FV((P(x)\to\exists y\ R(y,x))\backslash\{x\}\\
&=&FV(P(x))\cup FC(\exists y\ R(y,x))\backslash\{x\}\\
&=&\{x\}\cup(FV(R(y,x)\backslash\{y\})\backslash\{x\}\\
&=&\{x\}\cup(\{y,x\}\backslash\{y\})\backslash\{x\}\\
&=&\{x\}\cup\{x\}\backslash\{x\}\\
&=&\emptyset
\end{array}\]

\remark{$\LL$-Sentences have no Free Variables and thus no ambiguity in meaning.}

\section{Semantics of First-Order Languages}

\subsection{Structures, Variable Assignments \& Satisfaction}

\definition{$\LL$-Structure}
Let $\LL$ be a first-order language.\\
An \textit{$\LL$-Structure} is an ordered pair $\M=\langle D,\mathfrak{I}\rangle$
\begin{enumerate}
	\item $D$ is a non-empty set.
	\item $\mathfrak{I}$ is a function on the non-logical symbols of $\LL$ st
	\begin{itemize}
		\item[-] For each predicate symbol $P\in\mathcal{L}$ with $n$-arity.
		$$\mathfrak{I}(P)\subset D^n$$
		\item[-] For each function symbol $f$ of $\mathcal{L}$ with $n$-arity
		$$\mathfrak{I}(f):D^n\to D$$
		\item[-] For each constant symbol $c$ of $\mathcal{L}$
		$$\mathfrak{I}(c)\in D$$
	\end{itemize}
\end{enumerate}
\nb $D$ is the domain, $\mathfrak{I}$ is the interpretation.\\

\notation{$\LL$-Structure}
For ease we use the following notation wrt \textit{$\LL$-Structure}
$$|\M|:=D\quad f^\M:=\mathfrak{I}(f)\quad c^\M:=\mathfrak{I}(c)\quad p^\M=\mathfrak{I}(p)$$

\example{$\LL$-Structure}
Let $\LL_\text{Rng}:=\{\bar0,\bar1\bar+,\bar\cdot\}$ where $\bar+\ \&\ \bar\cdot$ are binary functions and $\bar0\ \&\ \bar1$ are constants.\\
(This is the language for ring theory)\\
We use the overline to distringuish language symbols from standard symbols.\\
Define
\[\begin{array}{rll}
D&:=&\reals\\
\mathfrak{I}(\bar0)&=&0\in\reals\\
\mathfrak{I}(\bar1)&=&1\in\reals\\
\mathfrak{I}(\bar+)&:&\reals\times\reals\to\reals\text{ with} (a,b)\mapsto(a+b)\\
\mathfrak{I}(\bar\cdot)&:&\reals\times\reals\to\reals\text{ with} (a,b)\mapsto(a\cdot b)
\end{array}\]
We recall $\langle D,\mathfrak{I}\rangle$ is the standard model of the real field.\\
\nb We can alternatively write $\langle D,\mathfrak{I}\rangle=\langle\reals,0,1,+,\cdot\rangle$ for neatness.\\

\definition{Variable Assignment}
A \textit{Variable Assignment} over an $\LL$-Structure is a function which maps from the set of variables to the domain of the $\LL$-Structure.
$$s:\text{Var}\to|\M|$$

\definition{Extension of Variable Assignment}
Let $\M$ be an $\mathcal{L}$-Structure \& $s$ be a variable assignment over $\M$.\\
The function $\bar{s}:T_{\M_\mathcal{L}}\to|\M|$ is defined using the following recursion
\begin{enumerate}
	\item $\bar{s}(t)=s(t)$ if $t\in\text{Var}$.
	\item $\bar{s}(t)=t^\M$ if $t$ is a constant symbol.
	\item $\bar{s}(f(t_1,\dots,t_k))=f^\M(\bar{s}(t_1),\dots,\bar{s}(t_k))$.
\end{enumerate}

\example{Variable Assignment}
Let $\M$ be the standard model of the real field.\\
Let $s$ bea variable assignment over $\M$ st $s(x)=s(y)=\pi$. Then
\[\begin{array}{rcl}
\bar{s}(x\bar+y)&=&\bar+^\M(\bar{s}(x),\bar{s}(y))\\
&=&\bar+^\M(s(x),s(y))\\
&=&\bar+^\M(\pi,\pi)\\
&=&\pi+\pi\\
&=&2\pi
\end{array}\]

\theorem{Substitution}
Let $s$ be a variable assignment over $\M$, $x\in\text{Var}$ \& $d\in|\M|$.\\
A new variable assignment $\frac{sd}{x}$ over $\M$ is defined as
$$\frac{sd}{x}(y)=\begin{cases}d&\text{if }y=x\\s(y)&\text{otherwise}\end{cases}$$

\definition{Satisfaction Relation}
Let $\M$ be an $\LL$-Structure \& $s$ be a variable assignment over $\M$.\\
The \textit{Satiscation Relation}, $\M,s\vDash\phi$ between $\M,s$ and $\LL$-Formula $\phi$ is recursively defined as
\begin{enumerate}
	\item $\M,s\vDash t_1\equiv t_2$ iff $\bar{s}(t_1)=\bar{s}(t_2)$.
	\item $\M,s\vDash P(t_1,\dots,t_k)$ iff $\langle\bar{s}(t_1),\dots,\bar{s}(t_k)\rangle\in P^\M\subset D^k$.
	\item $\M,s\vDash \neg\phi$ iff $\M,s\not\vDash\phi$.
	\item $\M,s\vDash\phi\to\psi$ iff if $\M,s\vDash\phi$ then $\M,s\vDash\psi$.
	\item $\M,s\vDash \forall x\phi$ iff for all $d\in|\M|$, $\M\frac{sd}{x}\vDash\phi$.
\end{enumerate}

\propositionn{Extension of Satisfaction Relation}
\[\begin{array}{rcl}
\M,s\vDash\phi\wedge\psi&\quad\text{iff}\quad&\M,s\vDash\phi\text{ and }\M,s\vDash\psi\\
\M,s\vDash\phi\vee\psi&\text{iff}&\M,s\vDash\phi\text{ or }\M,s\vDash\psi\\
\M,s\vDash\phi\leftrightarrow\psi&\quad\text{iff}\quad&\M,s\vDash\phi\text{ iff }\M,s\vDash\psi\\
\M,s\vDash\exists x\phi&\quad\text{iff}\quad&\M,s\frac{d}{x}\vDash\phi\text{ for some }d\in|\M|
\end{array}\]

\definition{Model}
Let $\Phi\subset\text{Fml}_\LL$, a subset of formulae of a first order language $\LL$.\\
$\M,s$ is a \textit{model} of $\Phi$ iff $\M,s\propto\phi\text{ for all}\phi\in\Phi$.\\
\nb This is denoted $\M,s\vDash\Phi$.\\

\example{Model}
Let $\M$ be the standard model of ring theory \& $s$ be a variable assignment over $\M$ st $s(v_1)=3$ \& $s(v_2)=-\pi$.\\
\[\begin{array}{rl}
&\M,s\vDash\bar0\bar< v_1\bar+v_2\\
\Longleftrightarrow&\bar<^\M(\bar{s}(\bar0),\bar{s}(v_1\bar+v_2))\\
\Longleftrightarrow&\bar<^\M(\bar{0}^\M,\bar{+}^\M(\bar{s}(v_1),\bar{s}(v_2)))\\
\Longleftrightarrow&\bar<^\M(0,\bar{+}^\M(s(v_1),s(v_2)))\\
\Longleftrightarrow&0<3+(-\pi)\\
\implies&\M,s\not\vDash\bar0\bar< v_1\bar+v_2
\end{array}\]

\[\begin{array}{rl}
&\M,s\vDash\forall v_2\exists v_0,\ v_2\bar<v_0\\
\Longleftrightarrow&\text{for all }d\in\reals,\ \M s\frac{d}{v_2}\vDash\exists v_0,\ v_2\bar<v_0\\
\Longleftrightarrow&\text{for all }e\in\reals,\ \M(s\frac{d}{v_2})\frac{e}{v_0}\vDash v_2\bar<v_0\\
\Longleftrightarrow&\text{for all }d\in\reals\text{ there is }e\in\reals,\ s(\frac{d}{v_2})\frac{e}{v_)}v_2<(s\frac{d}{v_0})\frac{e}{v_0}v_0\\
\Longleftrightarrow&\text{for all }d\in\reals\text{ there is }e\in\reals\text{ st }d<e
\end{array}\]

\theorem{}
Let $\LL_1,\LL_2$ be first order langauges.\\
Define models
\[\begin{array}{rcl}
\M_1&=&\langle D,\mathcal{I}_1\rangle:\LL_1\text{ structure}\\
\M_1&=&\langle D,\mathcal{I}_2\rangle:\LL_2\text{ structure}
\end{array}\]
Note that $D$ is the same for both (\ie Different languages, same world).\\
Let $\LL:=\LL_1\cup\LL_2$
\begin{enumerate}
	\item For all $\LL$-Terms, $t$, for all variable assignements $s_1$ over $\M_1$ \& $s_2$ over $\M_2$.\\
	If $\begin{cases}c^{\M_1}=c^{\M_2}&\text{ for all constants symbols that occur in }t\\f^{\M_1}=f^{\M_2}&\text{ for all functions symbols that occur in }t\\s_1(x)=s_2(x)&\text{ for all variable symbols that occur in }t\end{cases}$ then $\bar{s}_1(t)=\bar{s}_2(t)$.
	\item For all $\phi\in\text{Fml}_\LL$ \& for all variable assignemnts $s_1$ over $\M_1$ \& $s_2$ over $\M_2$.\\
	If $\begin{cases}c^{\M_1}=c^{\M_2}&\text{ for all constants symbols that occur in }\phi\\f^{\M_1}=f^{\M_2}&\text{ for all functions symbols that occur in }\phi\\R^{\M_1}=R^{\M_2}&\text{ for all predicate symbols that occur in }\phi\\s_1(x)=s_2(x)&\text{ for all variable symbols in FV}(\phi)\end{cases}$ then $\M_1s_1\vDash\phi$ iff $\M_2\vDash\phi$.\\
\end{enumerate}
\nb If $\LL=\emptyset$ it is not very interesting.\\

\proof{Theorem 3.2 i)}
\textit{This is a proof by induction on $\LL$-Term}.\\
\textbf{Base Case}\\
Let $t$ be atomic then $\bar{s}_1(t)=\bar{s}_2(t)$ is trivial, $\bar{s}_1(x)=s_1(x)=s_2(x)=\bar{s}_2(x)$ and $\bar{s}_1(c)=c^{\M_1}=c^{\M_2}=\bar{s}_2(c)$.\\
\textbf{Inductive Case}\\
Let $t=f(t_1,\dots,t_k)$. Then
\[\begin{array}{rcl}
\bar{s}_1(t)&=&f^{\M_1}(\bar{s}_1(t_1),\dots,\bar{s}_1(t_k))\\
&=&f^{\M_1}(\bar{s}_2(t_1),\dots,\bar{s}_2(t_k))\text{ by inductive hypothesis}\\
&=&f^{\M_2}(\bar{s}_2(t_1),\dots,\bar{s}_2(t_k))\\
&=&\bar{s}_2(t)
\end{array}\]\proved

\proof{Theorem 3.2 ii)}
\textit{This is a proof by induction on $\LL$-Formulae}.
\textbf{Base Case}\\
Let $\phi=R(t_1,\dots,t_k)$ be an atomic $\LL$-formula (\ie $cp(\phi)=0$).\\
Note that $FV(\phi)=\text{var}(\phi)$, thu conditions in \textbf{ii)} for $\phi$ imply the conditions of \textbf{i)} for $t_1,\dots,t_k$.\\
Therefore $\bar{s}_i(t_i)=\bar{s}_1(t_i)\ \forall\ i\in[1,k]$. Then
\[\begin{array}{rl}
&\M_1,s_1\vDash\phi\\
\Longleftrightarrow&\langle\bar{s}_1(t_1),\dots,\bar{s}_1(t_k)\rangle\in R^{\M_1}\\
\Longleftrightarrow&\langle\bar{s}_2(t_1),\dots,\bar{s}_2(t_k)\rangle\in R^{\M_1}\\
\Longleftrightarrow&\langle\bar{s}_2(t_1),\dots,\bar{s}_2(t_k)\rangle\in R^{\M_2}\\
\Longleftrightarrow&\M_2,s_2\vDash\phi
\end{array}\]
\textbf{Inductive Case}\\
Let $\phi:=\psi\to\theta$.\\
Since the conditions hold for $\phi$ they hold for $\psi\ \&\ \theta$. Then
\[\begin{array}{rl}
&\M_1,s_1\vDash\phi\\
\Longleftrightarrow&\text{if }\M_1,s_1\vDash\phi\text{ then }\M_1,s_1\vDash\theta\\
\overset{\text{by IH}}{\Longleftrightarrow}&\text{if }\M_2,s_2\vDash\phi\text{ then }\M_2,s_2\vDash\theta\\
\Longleftrightarrow&\M_2,s_2\vDash\phi
\end{array}\]
Let $\phi:=\neg\psi$>\\
By the inductive hypothesis the claim holds for $\psi$.\\
Since the conditions of \textbf{ii)} hold for $\phi$ they hold for $\psi$.\\
Note that $FV(\neg\psi)=FV(\psi)$. Hence
\[\begin{array}{rl}
&\M_1,s_1\vDash\phi\\
\Longleftrightarrow&\M_1,s_1\not\vDash\psi\\
\overset{\text{by IH}}{\Longleftrightarrow}&\M_2,s_2\not\vDash\psi\\
\Longleftrightarrow&\M_2,s_2\vDash\phi
\end{array}\]
Let $\phi:=\forall z\psi$.\\
By the last condition of \textbf{ii)} we have that $s_1(x)=s_2(x)\ \forall\ x\in FV(\phi)$.\\
Since $FV(\phi)\subset FV(\psi)\subset FV(\phi)\cup\{z\}$ it holds that $\forall\ d\in D$ that $s_1\frac{d}{z}(x)=s_2\frac{d}{z}(x)\ \forall\ x\in FV(\psi)$.\\
Meaning that $\forall\ d\in D$ the conditions of \textbf{ii)} hold for $\psi$ wrt $s_1\frac{d}{z}\ \&\ s_2\frac{d}{z}$.\\
Hence
\[\begin{array}{rl}
&\M_1,s_1\vDash\phi\\
\Longleftrightarrow&\forall\ d\in D,\ \M_1,s_1\frac{d}{z}\vDash\psi\\
\overset{\text{by IH}}\Longleftrightarrow&\forall\ d\in D,\ \M_2,s_2\frac{d}{z}\vDash\psi\\
\Longleftrightarrow&\M_2,s_2\vDash\phi
\end{array}\]\proved

\theorem{}
Let $\M$ be an $\LL$-Strucutre, $t$ be a closed $\LL$-Term, $\phi$ to be an $\LL$-Sentence and $s_1,s)2$ to be variable assignments over $\M$.\\
Then $\bar{s}_1(t)=\bar{s}_2(t)$ and $\M,s_1\vDash\phi$ iff $\M,s_2\vDash\phi$.\\
\nb This is since $t$ is closed and thus its sematnic value is indepedent of variable assignment.\\

\notation{}
Let $t$ be a closed $\LL$-Term \& $\phi$ an $\LL$-Sentence.\\
We use the following notation
\[\begin{array}{rcl}
t^\M&:=&\text{the unique }d\in D\text{ st }\ \bar{s}(t)=d\text{ for \textbf{some} variable assignment }s\text{ over }\M\\
&:=&\text{the unique }d\in D\text{ st }\ \bar{s}(t)=d\text{ for \textbf{all} variable assignment }s\text{ over }\M\\
\M\vDash\phi&:=&\M,s\vDash\phi\text{ for \textbf{some} variable assignment }s\text{ over }\M\\
&:=&\M,s\vDash\phi\text{ for \textbf{all} variable assignment }s\text{ over }\M\\
\end{array}\]
\nb The $s$ is dropped in $\M\vDash\phi$.

\subsection{Important Semantic Concepts}

\remark{Throughout this section $\LL$ will be a first-order language}

\definition{Logical Consequence}
Let $\phi\in\text{Fml}_\LL$ \& $\Phi\subset\text{Fml}_\LL$.\\
$\phi$ is said to be a \textit{Logical Consequence} of $\Phi$ iff $\forall\ \LL$-Structures, $\M$, and variable assignments, $s$, over $\M$ if $\M,s\vDash\Phi$ then $\M,s\vDash\phi$.\\
\nb When this holds we say $\phi$ logically follows from $\Phi$, denoted $\Phi\vDash\phi$.\\

\example{Logical Consequence}
TODO\\

\proposition{}
$\forall\ \phi,\psi\in\text{Fml}_\LL$ and $\Phi\subset\text{Fml}_\LL$
$$\underbrace{\Phi,\phi}_{\equiv\Phi\cup\{\phi\}}\vDash\psi\text{ iff }\Phi\vDash\phi\to\psi$$

\prooff{Proposition 3.2}
\[\begin{array}{rl}
&\Phi,\phi\vDash\psi\\
\Longleftrightarrow&\forall\M,s\text{ if }\M s\vDash\theta\ \forall\ \theta\in\Phi\cup\{\psi\}\text{ then }\M,s\vDash\psi\\
\Longleftrightarrow&\forall\M,s\text{ if }\M s\vDash\theta\ \forall\ \theta\in\Phi\text{ and }\M,s\vDash\phi\text{ then }\M,s\vDash\psi\\
\Longleftrightarrow&\text{if }\M,s\vDash\theta\ \forall\ \theta\in\Phi\text{ then }\M,s\vDash\phi\text{ implies }\M,s\vDash\psi\\
\overset{\text{by def}}{\Longleftrightarrow}&\Phi\vDash\phi\to\psi
\end{array}\]

\definition{}
Let $\Lambda$ be a set of $\LL$-sentences
$$\M\vDash\Lambda\text{ iff }\M\vDash\sigma\ \forall\ \sigma\in\Lambda$$

\example{}
Let $\LL=\LL_\text{GT}=\{e,\cdot\}$ the language of group theory.\\
Let $\Phi=\{\forall x\forall y\forall z\ (x\cdot y)\cdot z\equiv x\cdot(y\cdot z),\ \forall\ x\cdot e\equiv x,\ \forall x\exists y\ x\cdot y\equiv e\}$.\\
Then $\Phi\vDash\forall\ x\exists y$ st $y\cdot x\equiv e$ but $\Phi\not\vDash\forall x\forall y\ (x\cdot y)\equiv(y\cdot x)$.\\

\remark{}
We always have either $\M,s\vDash\phi$ or $\M s\not\vDash\phi$ since $\M s\vDash\phi\Leftrightarrow\M s\not\vDash\phi$.\\
But it is not always the case that either $\Phi\vDash\phi$ or $\Phi\not\vDash\phi$. (There may be some elements in a group with fulfil a criteria by chance).\\

\definition{Logically Valid}
Let $\phi\in\text{Fml}_\LL$.\\
$\phi$ is said to be \textit{Logically Valid} iff $\M,s\vDash\phi\ \forall\ \M,s$.\\
\nb This is also known as valid \& logically true.\\
\nb Denoted $\vDash\phi$ for short.\\

\examplee{Logically Valid}
\begin{itemize}
	\item[-] $\forall x\exists\ x\equiv y$ is \textit{Logically Valid} since trivially true for $y=x$.
	\item[-] $\exists xP(x)$ is \underline{not} \textit{Logically Valid}.\\
	Consider the case where $|\M|=\nats\ \&\ P^\M=\emptyset$ where $\M\not\vDash\exists xP(x)$.
\end{itemize}

\definition{Satisfiable}
Let $\phi\in\text{Fml}_\LL$ \& $\Phi\subset\text{Fml}_\LL$.\\
$\phi$ is \textit{Satisfiable} iff $\M,s\vDash\phi$ for some $\M,s$.\\
$\Phi$ is \textit{Satisfiable} iff $\M,s\vDash\Phi$ for some $\M,s$.\\

\examplee{Satisfiable}
\begin{itemize}
	\item[-] $\exists x P(x)$ is \textit{Satisfiable}.\\
	Since $|\M|=\nats\ \&\ P^\M=|\M|=\nats$ satisfies $\exists xP(x)$.
	\item[-] $x\not\equiv x$ is \underline{not} \textit{Satisfiable} as $\bar{s}(x)=s(x)=s(x)=\bar{s}(x)$ always and so $\M,s\vDash x\equiv x\ \forall\ \M,s$.
\end{itemize}

\theorem{}
Let $\phi\in\text{Fml}_\LL$ \& $\Phi\subset\text{Fml}_\LL$.
\begin{enumerate}
	\item $\phi$ is \textit{Logically Valid} iff $\emptyset\vDash\phi$.
	\item $\Phi\vDash\phi$ iff $\Phi\cup\{\neg\phi\}$ is \textit{Unsatisfiable}.
	\item $\phi$ is logically valid iff $\neg\phi$ is \textit{Unsatisfiable}.
\end{enumerate}

\prooff{Theorem 3.4}
\begin{enumerate}
	\item \[\begin{array}{rl}
	&\emptyset\vDash\phi\\
	\Longleftrightarrow&\text{for all }\M,s\underbrace{\text{if }\M,s\vDash\theta\ \forall\ \theta\in\emptyset}_{\text{Vacuously true}}\text{ then }\M,s\vDash\phi\\
	\Longleftrightarrow&\forall\ M,s\ \M,s\vDash\phi\\
	\Longleftrightarrow&\phi\text{ is logically valid}\\
	\end{array}\]
	\item \[\begin{array}{rl}
	&\Phi\vDash\phi\\
	\Longleftrightarrow&\forall\ \M,s\text{ if }\M,s\vDash\phi\text{ then }\M,s\vDash\phi\\
	\Longleftrightarrow&\text{ there is no }\M,s\text{ st }\M,s\vDash\Phi\text{ and }\underbrace{\M,s\not\vDash\phi}_{\M,s\vDash\neg\phi}
	\end{array}\]
	\item By $i)\ \&\ ii)$
\end{enumerate}

\definition{Logically Equivalent}
Let $\phi,\psi\in\text{Fml}_\LL$.\\
$\phi$ is \textit{Logically Equivalent} to $\psi$ iff $\phi\vDash\psi$ \& $\psi\vDash\phi$.\\
\nb Equivalently $\vDash\phi\leftrightarrow\psi$.

\proposition{Logical Equivalence}
Let $\phi,\psi\in\text{Fml}_\LL$.\\
$\phi\ \&\ \psi$ are \textit{Logically Equivalent} iff $\vDash\phi\to\psi$.\\
\ie $\phi\leftrightarrow\psi$ is \textit{Logically True}.\\

\proof{Logical Equivalence}
Recall that $\Phi,\phi\vDash\psi$ iff $\Phi\vDash\phi\to\psi$. Thus
\[\begin{array}{rl}
&\phi\vDash\psi\\
\Longleftrightarrow&\emptyset\cup\{\phi\}\vDash\\
\Longleftrightarrow&\emptyset\vDash\phi\to\psi\\
\Longleftrightarrow&\phi\to\psi
\end{array}\]
Similar for converse.\\
We have that $\phi\vDash\psi$ and $\psi\vDash\phi$ iff $\vDash\phi\to\psi$ and $\vDash\psi\to\phi$.\\
$\Longleftrightarrow\phi\vDash\psi$ and $\psi\vDash\phi$ iff $\vDash\phi\leftrightarrow\psi$.\\

\propositionn{Logical Equivalence}
\begin{enumerate}
	\item $((\phi\wedge\psi)\wedge\theta)$ is logically equivalent to $(\phi\wedge(\psi\wedge\theta))$.
	\item $((\phi\vee\psi)\vee\theta)$ is logically equivalent to $(\phi\vee(\psi\vee\theta))$.
	\item $\neg\neg\phi$ is logically equivalent to $\phi$.
	\item $\phi\wedge\psi$ is logically equivalent to $\neg(\neg\phi\vee\neg\psi$.
\end{enumerate}
\nb We write $\phi\wedge\psi\wedge\theta$ for $(\phi\wedge\psi)\wedge\theta$.

\subsection{Substitution}

\remark{}
If we have $P(x)\to Q(x)$ then $P(\bar0)\to Q(\bar0)$ and $P(f(y))\to Q(f(y))$.\\
If we have $\forall x(P(\bar0)\to Q(\bar0))$ the $\forall x$ is redundent.\\

\definition{Substitution in an $\LL$-Term}
Let $a,t\in T_{\M_\LL}$.\\
$[a]\frac{t}x$ denotes the result of replacing all occurences of $x$ in $a$ with $t$.\\
We define this substitution using the following recursive definition
\begin{enumerate}
	\item When $a$ is atomic:
	$$[a]\frac{t}x:=\begin{cases}t&\text{if }a\equiv x\\a&\text{otherwise}\end{cases}$$
	\item When $a=f(a_1,\dots,a_j)$ is a compound:
	$$[a]\frac{t}x:=f\left([a_1]\frac{t}x,\dots,[a_k]\frac{t}x\right)$$
\end{enumerate}

\examplee{Substitution in an $\LL$-Term}
\[\begin{array}{rl}
&[(x+y)+z]\frac{\bar0\cdot\bar0}y\\
\Longleftrightarrow&[x+y]\frac{\bar0\cdot\bar0}y\cdot[z]\frac{\bar0\cdot\bar0}y\\
\Longleftrightarrow&\left([x]\frac{\bar0\cdot\bar0}y+[y]\frac{\bar0\cdot\bar0}y\right)\cdot z\\
\Longleftrightarrow&(x+\bar0\cdot\bar0)\cdot z
\end{array}\]

\definition{Substitution in an $\LL$-Formula}
Let $t\in T_{\M_\LL},\ x\in\text{Var}$ and $\phi\in\text{Fml}_\LL$.\\
$[\phi]\frac{t}x$ denotes the result of replacing all occurences of $x$ in $\phi$ with $t$.\\
We define this substitution using the following recursive definition
\begin{enumerate}
	\item When $\phi:=(P(a_1,\dots,a_t)$ is atomic:
	$$[\phi]\frac{t}x=P\left([a_1]\frac{t}x,\dots,[a_k]\frac{t}x\right)$$
	\item When $\phi:=\neg\psi$:
	$$[\phi]\frac{t}x:=\neg[\psi]\frac{t}x$$
	\item When $\phi:=\psi\to\theta$:
	$$[\phi]\frac{t}x:=[\psi]\frac{t}x\to[\theta]\frac{t}x$$
	\item When $\phi:=\forall z\psi$:
	$$[\phi]\frac{t}x=\begin{cases}\forall z[\psi]\frac{t}x&\text{if }x\not\equiv z\\\phi&\text{otherwise}\end{cases}$$
	\nb The $\mathtt{otherwise}$ case is due to all $x$ variables being bounded.
\end{enumerate}

\example{Substitution in an $\LL$-Formula}
Let $x\not\equiv y$
\[\begin{array}{rl}
&[\forall xP(x)\to\forall yR(x,y)]\frac{c}x\\
=&[\forall xP(x)]\frac{c}x\to[\forall yR(x,y)]\frac{c}x\\
=&\forall xP(x)\to\forall y[R(x,y)]\frac{c}x\\
=&\forall xP(x)\to\forall yR([x]\frac{c}x,[y]\frac{c}x)\\
=&\forall xP(x)\to\forall yR(c,y)
\end{array}\]

\proposition{}
For every $x\in\text{Var},\ a,t\in T_{\M_\LL}$ and $\phi\in\text{Fml}_\LL$ the following results hold
$$[a]\frac{x}{x}=a\quad\text{and}\quad[\phi]\frac{x}{x}=\phi$$

\proof{Proposition 3.5}
TODO\\
\textit{Induction on terms and then on formulae}\\

\proposition{}
For every $x\in\text{Var},\ a,t\in T_{\M_\LL}$ and $\phi\in\text{Fml}_\LL$.
\begin{enumerate}
	\item If $x\not\in\text{Var}(a)$ then $[a]\frac{t}{x}=a$.
	\item If $x\not\in\text{FV}(\phi)$ then $[\phi]\frac{t}{x}=\phi$.
\end{enumerate}

\proof{Proposition 3.6 ii)}
\textit{Proof by induction on terms, and then on formulae}.\\
\textit{Base Case}\\
Let $\phi:=P(a_1,\dots,a_k)$ be atomic.\\
Suppose $x\in\text{FV}(\phi)$\\
We have that $x\not\in FV(\phi)\underbrace{=\var(\phi)}_{\phi\text{ is atomic}}$\\
Then $x\not\in\var(a_i)\ \forall\ i\in[1,k]$.
\[\begin{array}{rl}
&[\phi]\frac{t}x\\
=&P([a_1]\frac{t}x,\dots,[a_k]\frac{t}x)\\
=&P(a_1,\dots,a_k)\\
=&\phi
\end{array}\]
Result holds for base case\\
\\
\textit{Inductive Case}
Let $\phi=\forall z\psi$.\\
Suppose $x\not\in FV(\phi)$.\\
Then $FV(\phi)=FV(\psi)\backslash\{z\}$.\\
If $x\not\in FV(\psi)$ then $[\phi]\frac{t}x=\begin{cases}\phi&\text{if }x=z\\\forall z[\phi]\frac{t}{x}\underbrace{=\forall z\phi}_\text{by IH}&\text{otherwise}\end{cases}$.\\
Otherwise $x=z$ and $[\phi]\frac{t}x=\phi$.\\

\proposition{}
Let $a,t\in T_{\M_\LL},\ \phi\in\text{Fml}_\LL,\ x\in\var$ with $x\not\in t$. Then
\begin{enumerate}
	\item $x\not\in\var\left([a]\frac{t}{x}\right)$.
	\item $x\not\in FV\left([\phi]\frac{t}{x}\right)\subset\left([\phi]\frac{t}{x}\right)$.
	\item $x\not\in\var\left([\phi]\frac{t}{x}\right)$.
\end{enumerate}
\nb Proof is done by induction on terms \& formulae.\\

\remark{}
From $\forall xP(x)$ being true, we can infer that $P(y)\equiv[P(x)]\frac{y}x,\ P(f(y))=[P(x)]\frac{f(y)}x$ \& ${P(\bar0)\equiv[P(\bar0)]\frac{\bar0}x}$ are all true.\\
\underline{but} $\forall x\phi$ being true does not mean that $[\phi]\frac{y}x$ and $[\phi]\frac{\bar0}x$ are true.\\

\example{Remark 3.4}
We have that $\forall x\exists y\ y\bar<x$ is true, but $\exists y\ y\bar<y$ is not true.\\
\ie Everyone is liked by someone $\not\implies$ someone is liked by themselves.\\

\definition{Substitutablity}
\textit{Refers to valid substitutions}.\\
Let $x\in\var,\ t\in T_{\M_\LL}\ \&\ \phi\in\text{Fml}_\LL$.\\
We use the notation $\mathtt{SubSt}(t,x,\phi)$ to mean $t$ is substitutable for $x$ in $\phi$.\\
We define \textit{Substitutability} using the following recursive definition
\begin{enumerate}
	\item $\phi$ is atomic then
	$$\mathtt{SubSt}(t,x,\phi)\ \forall\ x\in\var,t\in T_{\M_\LL}$$
	\item $\phi=\not\psi$ then
	$$\mathtt{SubSt}(t,x,\phi)\text{ iff }\mathtt{SubSt}(t,x,\psi)$$
	\item $\phi=\psi\to\theta$ then
	$$\mathtt{SubSt}(t,x,\phi)\text{ iff }\mathtt{SubSt}(t,x,\psi)\wedge\mathtt{SubSt}(t,x,\theta)$$
	\item $\phi=\forall z\psi$ then
	$$\mathtt{SubSt}(t,x,\phi)\text{ iff }\begin{cases}z\not\in\var(t)\wedge\mathtt{SubSt}(t,x,\psi)&\text{or}\\x\not\in FV(\phi)\end{cases}$$
\end{enumerate}
\nb the second case in $iv)$ is a vacuous case since there are no variables to substitute.\\

\example{Substitutability}
Let $x\neq y\neq z$
\begin{enumerate}
	\item $\mathtt{SubSt}(t,x,P(x))\ \forall\ t\in T_{\M_\LL}$.
	\item $\mathtt{SubSt}(t,y,P(y))\ \forall\ t\in T_{\M_\LL}$.
	\item $\mathtt{SubSt}(t,x,\neg P(z))\ \forall\ t\in T_{\M_\LL}$.
	\item $\mathtt{SubSt}(t,x,P(x)\to\neg P(z))\ \forall\ t\in T_{\M_\LL}$.
	\item $\mathtt{SubSt}(t,x,\forall x\ (P(x)\to\neg P(z))\ \forall\ t\in T_{\M_\LL}$ since $x,y\not\in FV$.
	\item $\mathtt{SubSt}(t,y,\forall x\ (P(x)\to\neg P(z))\ \forall\ t\in T_{\M_\LL}$ since $x,y\not\in FV$.
	\item $\neg\mathtt{SubSt}(f(x),z,\forall x(P(x)\to\neg P(z)))\ \forall\ t\in T_{\M_\LL}$ since $z\not\in FV$.
\end{enumerate}


\end{document}
