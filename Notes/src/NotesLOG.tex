\documentclass[11pt,a4paper]{article}

\usepackage[margin=1in, paperwidth=8.3in, paperheight=11.7in]{geometry}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{changepage} 

\begin{document}

\pagestyle{fancy}
\setlength\parindent{0pt}
\allowdisplaybreaks

\renewcommand{\headrulewidth}{0pt}
\setlist[enumerate,1]{label={\roman*)}}


% Cover page title
\title{Logic - Notes}
\author{Dom Hutchinson}
\date{\today}
\maketitle

% Header
\fancyhead[L]{Dom Hutchinson}
\fancyhead[C]{Logic - Notes}
\fancyhead[R]{\today}

% Counters
\newcounter{definition}[subsection]
\newcounter{example}[section]
\newcounter{notation}[section]
\newcounter{proposition}[section]
\newcounter{proof}[section]
\newcounter{remark}[section]
\newcounter{theorem}[section]

% commands
\newcommand{\dotprod}[0]{\boldsymbol{\cdot}}
\newcommand{\cosech}[0]{\mathrm{cosech}\ }
\newcommand{\cosec}[0]{\mathrm{cosec}\ }
\newcommand{\sech}[0]{\mathrm{sech}\ }
\newcommand{\prob}[0]{\mathbb{P}}
\newcommand{\nats}[0]{\mathbb{N}}
\newcommand{\cov}[0]{\mathrm{Cov}}
\newcommand{\var}[0]{\mathrm{Var}}
\newcommand{\expect}[0]{\mathbb{E}}
\newcommand{\reals}[0]{\mathbb{R}}
\newcommand{\integers}[0]{\mathbb{Z}}
\newcommand{\indicator}[0]{\mathds{1}}
\newcommand{\nb}[0]{\textit{N.B.} }
\newcommand{\ie}[0]{\textit{i.e.} }
\newcommand{\eg}[0]{\textit{e.g.} }
\newcommand{\X}[0]{\textbf{X}}
\newcommand{\x}[0]{\textbf{x}}
\newcommand{\iid}[0]{\overset{\text{iid}}{\sim}}
\newcommand{\proved}[0]{$\hfill\square$\\}
\newcommand{\LL}[0]{\mathcal{L}}

\newcommand{\definition}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}\\}
\newcommand{\definitionn}[1]{\stepcounter{definition} \textbf{Definition \arabic{section}.\arabic{definition}\ - }\textit{#1}}
\newcommand{\proof}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}\\}
\newcommand{\prooff}[1]{\stepcounter{proof} \textbf{Proof \arabic{section}.\arabic{proof}\ - }\textit{#1}}
\newcommand{\example}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}\\}
\newcommand{\examplee}[1]{\stepcounter{example} \textbf{Example \arabic{section}.\arabic{example}\ - }\textit{#1}}
\newcommand{\notation}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}\\}
\newcommand{\notationn}[1]{\stepcounter{notation} \textbf{Notation \arabic{section}.\arabic{notation}\ - }\textit{#1}}
\newcommand{\proposition}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}\\}
\newcommand{\propositionn}[1]{\stepcounter{proposition} \textbf{Proposition \arabic{section}.\arabic{proposition}\ - }\textit{#1}}
\newcommand{\remark}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}\\}
\newcommand{\remarkk}[1]{\stepcounter{remark} \textbf{Remark \arabic{section}.\arabic{remark}\ - }\textit{#1}}
\newcommand{\theorem}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}\\}
\newcommand{\theoremm}[1]{\stepcounter{theorem} \textbf{Theorem \arabic{section}.\arabic{theorem}\ - }\textit{#1}}

\tableofcontents

% Start of content
\newpage

\section{Introduction}

\subsection{Alphabets \& Strings}

\definition{Alphabet}
An \textit{Alphabet} is a set of symbols from which \textit{Strings} can be created.\\

\definition{String}
A \textit{String} over a set $\mathcal{A}$ is any sequence $\alpha:=\langle a_1,\dots,a_n\rangle$ where $a_1,\dots,a_n\in\mathcal{A}$.\\
\nb Here we say $\alpha$ has \textit{length} $n$ and $\alpha\in\mathcal{A}^n$.\\

\definition{Power Set}
Let $\mathcal{A}$ be an alphabet. We define
$$\mathcal{A}^*:=\bigcup\limits_{n\in\nats}\mathcal{A}^n=\{\langle a_1,\dots,a_n\rangle:n\in\nats;a_1,\dots,a_n\in\mathcal{A}\}$$
This means $\mathcal{A}^*$ is the set of all possible strings over alphabet $\mathcal{A}$.\\

\remark{Concatenating Strings}
Define \textit{Strings} $\alpha:=\langle a_1,\dots,a_n\rangle\in\mathcal{A}^n$ and $\beta:=\langle b_1,\dots,b_m\rangle\in\mathcal{A}^m$.\\
We define \textit{Concatenation} of $\alpha$ \& $\beta$ as
$\alpha\beta:=\langle a_1,\dots,a_n,b_1,\dots,b_m\rangle$
Note that
$$\alpha\beta\neq\langle\alpha,\beta\rangle=\langle\langle a_1,\dots,a_n\rangle,\langle b_1,\dots,b_m\rangle\rangle$$
\nb Sometimes the following notation is used $\alpha*\beta$.

\example{English Alphabet}
If we define an alphabet $\mathcal{A}:=\{`a`,\dots,`z`\}$ then $\langle`t`,`h`,`i`,`s`\rangle$ is a \textit{String} of $\mathcal{A}$.\\

\remark{Ambiguity when using multiple Alphabets}
Consider the \textit{Alphabets} $\mathcal{A}_1:=\{0,1,\dots,9\}$ \& $\mathcal{A}_2:=\nats$.\\
Then we are unsure which of the following definitions of $123$ is valid
$$\langle123\rangle,\ \langle12,3\rangle,\ \langle1,23\rangle, \langle1,2,3\rangle$$

\remark{$\mathcal{A}:=\{0,1\}$ is sufficient to describe any language - binary}

\remark{Describing Formal Languages}
When describing a \textit{Formal Language} we need to provide two things
\begin{enumerate}
	\item An \textit{Alphabet} which defines what symbols are allowed.
	\item A \textit{Grammar} which defines what combinations of symbols are allowed.
\end{enumerate}

\subsection{Countable Sets}

\definition{Countable Set}
A set $X$ is said to be \textit{Countable} if
\[\begin{array}{l}
\exists\text{ a surjection  }f:\nats\to X\\
\exists\text{ an injection }f:X\to\nats
\end{array}\]

\definition{Countably Infinite Set}
A set $X$ is said to be \textit{Countably Infinite} if $\exists$ a bijection $f:X\to\nats$.\\

\theorem{Power set is Countable}
If set $\mathcal{A}$ is \textit{countable} then $\mathcal{A}^*$ is \textit{countable}.\\

\proof{Theorem 1.1}
Let $f:\mathcal{A}\longrightarrow\nats$ (This function exists trivally since we define $\mathcal{A}$ to be countable).\\
Define the following function $g(\cdot):\mathcal{A}^*\longrightarrow\nats$
$$g(\langle a_1,\dots,a_n\rangle):=p_1^{f(a_1)+1}\cdot\dots\cdot p_n^{f(a_n)+1}$$
where $p_i$ is the $i^\text{th}$ prime.\\
Since each natural number can be described by a unique composition of primes and since $f(\dot)$ is injective, then $g(\cdot)$ is injective.\\
Thus there exists an injection from $\mathcal{A}^*$ to $\nats$, making $\mathcal{A}^*$ countable.\\

\theorem{If $\mathcal{A}$ is countable, then so are $\mathcal{A}^*,(\mathcal{A}^*)^*,\dots$}

\section{First-Order Languages}

\definition{First-Order Language, $\LL$}
The \textit{Alphabet} of a \textit{First-Order Language}, comprises of the following, pairwise disjoint, categories (and nothing else)
\begin{enumerate}
	\item Negation, $\neg$, and implication, $\longrightarrow$.
	\item For all, $\forall$.
	\item Infinitely many variables, $\{v_0,v_1,\dots\}$.
	\item Parentheses, `$($' `$)$', and comman `$,$'.
	\item Equality, $\equiv$, which is the only logical predicate symbol with 2-arity.
	\item A set of constant symbols, $\{c_1,c_2,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity function symbols $\{f_1^n,f_2^n,\dots\}$. (Possibly empty)
	\item For each $n\geq1$, a set of $n$-arity non-logical predicate symbols $\{P_1^n,P_2^n,\dots\}$. (Possibly empty)
\end{enumerate}
\nb We denote the set of variables by $Var:=\{v_0,v_1,\dots\}$; denote a language as $\LL$ and the alphabet of $\LL$ as $\mathcal{A_L}$.\\
\nb In this course \textit{Alphabets} are restricted to being \textit{Countable}.\\

\definition{Negation, $\neg$}
Negation returns in the inverse of a predicate (DO I MEAN PREDICATE)
\begin{center}
\begin{tabular}{c|c}
$P$&$\neg P$\\\hline
T&F\\
F&T
\end{tabular}
\end{center}

\definition{Implication, $\longrightarrow$}
Implication returns whether one predicate being true necessarily implies a second predicate being true
\begin{center}
\begin{tabular}{cc|c}
$P$&$Q$&$P\to Q$\\\hline
T&T&T\\
T&F&F\\
F&T&T\\
F&F&T
\end{tabular}
\end{center}

\remark{First-Order Languages don't have $\wedge,\ \vee,\ \exists$}
Alphabets for \textit{First-Order Languages} do not contain propositional connectives for AND, $\wedge$, OR, $\vee$, or EXISTS,$\exists$ since they can be expressed as a combination of negation \& implication.
\[\begin{array}{rcl}
P\vee Q&\Longleftrightarrow& \neg P\to Q\\P\wedge Q&\Longleftrightarrow&\neg(P\to\neg Q)\\
\exists\ x\text{ st }P(x)\text{ is true}&\Longleftrightarrow&\neg(\forall\ x,\ \neg P(x))
\end{array}\]
\begin{center}
\begin{tabular}{cc}
\begin{tabular}{cc|c|c}
$P$&$Q$&$\neg P$&$\neg P\to Q$\\\hline
T&T&F&T\\
T&F&F&T\\
F&T&F&T\\
F&F&F&F
\end{tabular}&
\begin{tabular}{cc|c|c|c}
$P$&$Q$&$\neg Q$&$P\to\neg Q$&$\neg(P\to\neg Q)$\\\hline
T&T&F&F&T\\
T&F&T&T&F\\
F&T&F&T&F\\
F&F&T&T&F
\end{tabular}
\end{tabular}\\
\end{center}

\example{Recursive Defintion}
Consider the following, normal, deifition
$$x\text{ is a multiple of }5\Longleftrightarrow\exists\ y\in\mathbb{Z}\ \text{st}\ y.5=x$$
We can instead use the recursive definition
\begin{enumerate}
	\item $0$ is a multiple of $5$.
	\item If $n$ is a multiple of 5 then $n+5$ is a multiple of 5.
\end{enumerate}

\definition{$\LL$-Term \& Complexity}
Let $\LL$ be a \textit{First-Order Language}.\\
We define \textit{$\LL$-Terms} \& \textit{Complexity}, $cp(\cdot)$, together using the following \textit{recursive definition}
\begin{enumerate}
	\item If $s$ is a variable or a constant symbol, then $s$ is an \textit{$\LL$-Term} with $cp(s)=0$.\\
	\nb Terms with $cp(\cdot)=0$ are called \textit{Atomic Terms}.
	\item If $f$ is a fucntion symbol with $k$-arity \& if $a_1,\dots,a_k$ are \textit{$\LL$-Terms} then $f(a_1,\dots,f_k)$ is an \textit{$\LL$-Term} with complexity
	$$cp(f(a_1,\dots,a_k)):=\max\{cp(a_1),\dots,cp(a_k)\}+1$$
	\nb Terms with $cp(\cdot)\geq1$ are called \textit{Compound Terms}.
	\item Nothing else is an \textit{$\LL$-Term}
\end{enumerate}
\nb We denote the set of $\LL-\text{Terms}$ by $T_\mathcal{M_L}$.\\

\example{Complexity}
Let $\{c,d,f,g,h,p\}\subseteq\L$ with $c,d$ being constants, $g,p$ being uniary functions \& $f,h$ being binary functions.\\
Show that the following is an $\LL$\textit{-Term} \& find its \textit{Complexity}
$$h(g(f(x,c)),p(d))$$
\begin{enumerate}
	\item $x$ is an $\LL$\textit{-Term} with $cp(x)=0$ by $(i)$.
	\item $c\ \&\ d$ are $\LL$\textit{-Terms} with $cp(c)=0=cp(d)$ by $(i)$.
	\item $f(x,c)$ is an $\LL$\textit{-Term} with $cp(f)=\max{0,0}+1=1$ by $(ii)$.
	\item $p(d)$ is an $\LL$\textit{-Term} with $cp(f)=\max{0}+1=1$ by $(ii)$.
	\item $g(f(x,c),p(d))$ is an $\LL$\textit{-Term} with $cp(g)=\max{1,1}+1=2$ by $(ii)$.
	\item $h(g(f(x,c),p(d)))$ is an $\LL$\textit{-Term} with $cp(h)=\max{2}+1=3$ by $(ii)$.
\end{enumerate}
Thus $h(g(f(x,c),p(d)))$ is an $\LL$\textit{-Term} with \textit{Complexity} 3.\\

\notation{More readble Functions}
WE often write $x\circ y$ instead of $\circ(x,y)$ as it is more readable (even though the later is technically the only correct notation). Similarly, $x+y$ instead of $+(x,y)$.\\

\definition{Atomic Formulae}
Let $\LL$ be a \textit{First-Order Language}.\\
The atomic $\LL$\textit{-Formulae} are those strings over $\mathcal{A_L}$ of the form
$$R(t_1,\dots,t_n)\text{ for }n\in\nats$$
where $R$ is a predicate symbol of $\LL$ with $n$-arity and $t_1,\dots,t_n$ are $\LL$\textit{-terms}.\\
\nb $\equiv(t_1,t_2)$ is an \textit{Atomic $\LL$-Formula} for each $\LL$ terms $t_1,t_2$.\\

\definition{$\LL$-Formulae \& Complexity}
We define \textit{$\LL$-Formulae} \& \textit{Complexity}, $cp(\cdot)$, together using the following recursive definition
\begin{enumerate}
	\item If $\phi\in\mathcal{A}^*_\LL$ is an \textit{Atomic $\LL$-Formula} then $\phi$ is an \textit{$\LL$-Formula} with $cp(\phi)=0$.
	\item If $\phi$ is an \textit{$\LL$-Formula} with $cp(\phi)=n$ then $\neg\phi$ is an \textit{$\LL$-Formula} with $cp(\neg\phi)=n+1$.
	\item If $\phi\ \&\ \psi$ are \textit{$\LL$-Formulae} then $\phi\to\psi$ is an \textit{$\LL$-Formula} with ${cp(\phi\to\psi)=\max\{cp(\phi),cp(\psi)\}+1}$.
	\item if $\phi$ is an \textit{$\LL$-Formula} then $\forall x\phi$ is an \textit{$\LL$-Formula} with $cp(\forall x\phi)=cp(\phi)+1$, where $x$ is a variable.
\end{enumerate}
\nb \textit{Complexity} is just a measure of the syntactic complexity, not semantic. Notice how ${cp(\neg\neg\phi)=cp(\phi)+2}$.\\

\remark{Formulae are uniquely readable \& parsable}

\example{\textit{$\LL$-Formulae} Complexity}
Let $\{R,f\}\subset\mathcal{L}$ be binary operations.\\
Show that the following is an \textit{$\LL$-Formula}
$$\forall\ v_0\ (\neg R(f(v_0,v_2),v_2)\longrightarrow\underbrace{\equiv(v_0,v_2)}_{v_0\equiv v_2}$$
\begin{enumerate}
	\item $v_0,v_2$ are $\LL$-Terms.
	\item $f(v_0,v_2)$ is an $\LL$-Term.
	\item $R(f(v_0,v_2),v_2)$ is an $\LL$-Formula with $cp(\cdot)=0$.
	\item $\neg R(f(v_0,v_2),v_2)$ is an $\LL$-Formula with $cp(\cdot)=0+1=1$.
	\item $\equiv(v_0,v_2)$ is an $\LL$-Formula with $cp(\cdot)=0$.
	\item $\neq R(f(v_0,v_2),v_2)\longrightarrow\equiv(v_0,v_2)$ is an $\LL$-Formula with $cp(\cdot)=\max\{0,1\}+1=2$.
	\item $\forall\ v_0\ (\neg R(f(v_0,v_2),v_2)\longrightarrow\equiv(v_0,v_2))$ is an $\LL$-Formula with $cp(\dot)=2+1=3$.
\end{enumerate}

\notation{Convention for common operators}
To make formulae more readble we general make the following allowances in notation
\[\begin{array}{rcl}
t_1\equiv t_2&\text{for}&\equiv(t_1,t_2)\\
t_1\not\equiv t_2&\text{for}&\neg\equiv(t_1,t_2)\\
t_1< t_2&\text{for}&<(t_1,t_2)\\
t_1\not\equiv t_2&\text{for}&\neg\equiv(t_1,t_2)
\end{array}\]
Further, when a formula is encapsulated by parantheses then we will often surpress the outermost parentheses (only), as they do not affect anything.
$$\phi\longrightarrow(\psi\longrightarrow\theta)\text{ for }(\phi\longrightarrow(\psi\longrightarrow\theta))$$

\definitionn{More complex operators}
\begin{itemize}
	\item[-] AND, $(\phi\wedge\psi):=\neg(\phi\longrightarrow\neg\psi)$.
	\item[-] OR, $(\phi\vee\psi):=(\neg\phi\longrightarrow\psi)$.
	\item[-] IFF, $(\phi\longleftrightarrow\psi):=(\phi\longrightarrow\psi)\wedge(\psi\longrightarrow\phi)$.
	\item[-] EXISTS, $(\exists\ x\phi):=\neg\forall\ x\ \neg\phi$.
\end{itemize}

\notationn{Sets of $\LL$ Features}
\begin{itemize}
	\item[-] $T_\mathcal{M_L}:=$ Set of $\LL$-Terms.
	\item[-] $F_\mathcal{M_L}:=$ Set of $\LL$-Formulae.
	\item[-] $\text{Var}:=$ Set of Variables.
\end{itemize}

\propositionn{$T_\mathcal{M_L}\ \&\ F_\mathcal{M_L}$ are always countable in this course since we assume $\LL$ to be finite.}

\subsection{Induction of Terms \& Formulae}

\theorem{Inheritance of a Proeprty - $\LL$-Terms}
Let $P$ be a property of $\LL$-Terms.\\
Suppose the following to be true
\begin{enumerate}
	\item All \textit{Atomic $\LL$-Terms} have property $P$.
	\item $\forall\ k\in\nats,\ \forall$ function symbols $f$ with $k$-arity:
	If $\LL$-Terms $t_1,\dots,t_k$ have property $P$ then $f(t_1,\dots,t_k)$ has $P$.
\end{enumerate}
Then every $\LL$-Term has property $P$.\\

\proof{Theorem 2.1}
\textit{This is a proof by contradiction}.
Suppose that $i)\ \&\ ii)$ are true but there exists some $\LL$-Term which does not have $P$.\\
Let $t$ be an $\LL$-Term with minimum complexity st $t$ does not have $P$.\\
Then $cp(t)\neq0$ otherwise $i)$ would be untrue.\\
Thus $t\equiv f(t_1,\dots,t_k)$ by the minimlaity of $cp(t)$.\\
We know that $t_1,\dots,t_k$ have $P$.\\
Thus $f(t_1,\dots,t_k)$ has $P$. This is a contradiction.\\

\theorem{Inheritance of a Proeprty - $\LL$-Formulae}
Let $P$ be a property of $\LL$-Formula.\\
Suppose the following to be true
\begin{enumerate}
	\item All \textit{Atomic $\LL$-Formulae} have property $P$.
	\item If $\phi,\psi\in F_\mathcal{M_L}$ have $P$ then $\neg\phi,(\phi\to\psi)\ \&\ \forall\ x\phi$ have $P$ to.
\end{enumerate}
Then every $\LL$-Formulae has property $P$.\\

\theorem{Number of Parenthese}
Ever \textit{$\LL$-Formula} has as many left parentheses as right parentheses.\\
Ever \textit{$\LL$-Term} has as many left parentheses as right parentheses.\\

\proof{Theorem 2.3}
\textit{This is a proof by induction}.\\
Let $P$ be the property \textit{``Has as many left parenthese as right''}.\\
\underline{Base Case} - When $\phi$ is an \textit{Atomic $\LL$ Formula} it trivially has equal number of parenthese.\\
\underline{Inductive Case}\\
Let $\phi\ \&\ \psi$ be arbitrary $\LL$-Formulae.\\
Assume that $P(\phi)$ \& $P(\psi)$ hold.\\
We need to show that $P(\neg\phi),\ P(\phi\to\psi)\ \&\ P(\forall\ x\phi)$ all hold.\\
We do not need to show $P(\neg\psi),\ P(\psi\to\phi)\ \&\ P(\forall\ x\psi)$ hold as $\phi\ \&\ \psi$ are arbitrary.\\
We have that $\neg\phi$ and $\forall\ x\phi$ don't add any brackets, so $P$ holds.\\
We have that $(\phi\to\psi)$ add one left \& one right parentheses (although they are often surpressed), thus $P$ holds.\\
Thus by the process of mathematical induction $P$ holds forall $\LL$-Formulae.\\
\nb The proof for $\LL$-Terms is very similar.

\subsection{Free Variables}

\definition{Variable Function, $var(\cdot)$}
Define $var:\mathcal{A_L}^*\to2^\text{Var}$ st $var(s)$ is the set of all variables in string $s$.\\

\examplee{$\var(\cdot)$}
\[\begin{array}{rcl}
var(f(x,f(y,c))&=&\{x,y\}\\
var(f(c,f(c,c))&=&\emptyset\\
var(\equiv,\equiv,\equiv)&=&\emptyset\text{ nonsense strins are acceptable}
\end{array}\]

\definition{Free Variables}
\textit{Free Variables} are variables whose value are ambiguous in an \textit{$\LL$-Formula}.\\

\definition{Free Variable Function, $FV(\cdot)$}
We recursively define $FV(\phi)$ for \textit{$\LL$-Formulae} as $\phi$ as follows
\begin{enumerate}
	\item $FV(\phi)=var(\phi)$ if $\phi$ is an \textit{Atomic $\LL$-Formula}.
	\item $FV(\neg\phi)=FV(\phi)$.
	\item $FV((\phi\to\psi))=FV(\phi)\cup FV(\psi)$.
	\item $FV(\forall\ x\phi)=FV(\phi)\backslash\{x\}$.
\end{enumerate}

\examplee{Free Variable Function}
\[\begin{array}{rcl}
FV(\forall x(P(y)\to Q(x)))&=&FV(P(y)\to Q(x))\backslash\{x\}\\
&=&[FV(P(y))\cup FV(Q(x))]\backslash\{x\}\\
&=&[\{y\}\cup\{x\}]\backslash\{x\}\\
&=&\{y\}
\end{array}\]

\propositionn{Free Variable Function for more complex operators}
\[\begin{array}{rcl}
FV(\phi\wedge\psi)&=&FV(\neg(\phi\to\neg\psi))\text{ by definition of }\wedge\\
&=&FV(\phi)\cup FV(\psi)\\
FV(\phi\vee\psi)&=&FV(\neg\phi\to\psi)\text{ by definition of }\vee\\
&=&FV(\phi)\cup FV(\psi)\\
FV(\exists x\phi)&=&FV(\neg\forall x\neg\phi)\text{ by definition of }\exists\\
&=&FV(\phi)\backslash\{x\}
\end{array}\]

\definition{Closed $\LL$-Term}
Let $t$ be an $\LL$-Term.\\
If $var(t)=\emptyset$ then $t$ is called a \textit{Closed $\LL$-Term}.\\

\definition{$\LL$-Sentence}
Let $\phi$ be an $\LL$-Formula.\\
If $FV(\phi)=\emptyset$ then $\phi$ is called an \textit{$\LL$-Sentence}.\\

\examplee{$\LL$-Sentence}
\[\begin{array}{rcl}
FV(\forall x(P(x)\to\exists y\ R(y,x))&=&FV((P(x)\to\exists y\ R(y,x))\backslash\{x\}\\
&=&FV(P(x))\cup FC(\exists y\ R(y,x))\backslash\{x\}\\
&=&\{x\}\cup(FV(R(y,x)\backslash\{y\})\backslash\{x\}\\
&=&\{x\}\cup(\{y,x\}\backslash\{y\})\backslash\{x\}\\
&=&\{x\}\cup\{x\}\backslash\{x\}\\
&=&\emptyset
\end{array}\]

\remark{$\LL$-Sentences have no Free Variables and thus no ambiguity in meaning.}

\end{document}
